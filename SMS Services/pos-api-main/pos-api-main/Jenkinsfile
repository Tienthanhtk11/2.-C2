def listSuccessImage = []
def listFailImage = []
def listChangeServices = []
def chatID = "-1001547311638"
def printAll(list) {
  def returnString = ""
  list.each { item ->
    returnString = returnString + "\n" + "\t" + "-" + item
  }
  return returnString
}
def dockerRepo = "smartgapjsc"
def project = "pos"
def dockerTag = ""
def dockerImage = ""
def server = [
  "develop"   :  "192.168.0.21",
  "staging"   :  "192.168.0.22",
  "main"   :  "192.168.0.20"
]
def theLatestTag = ""

pipeline {
  agent any

  options {
    gitLabConnection('Gitlab server connection')
  }

  parameters {
    booleanParam(name: 'BUILD_ALL', defaultValue: false, description: 'Choose to build all microservices')
  }

  stages {
    stage('Initialization') {
      steps {
        script {
          withCredentials([gitUsernamePassword(credentialsId: 'devops',   gitToolName: 'git-tool')]) {
            theLatestTag = sh (returnStdout: true, script: "git ls-remote --tags --sort=committerdate | grep -Po '[0-9]+\\.[0-9]+\\.[0-9]+' | tail -n 1").trim()
          }
          if (env.BRANCH_NAME != "staging") {
            dockerTag = "${env.GIT_COMMIT.substring(0,8)}-${env.BRANCH_NAME}"
          } else {
            dockerTag = sh (returnStdout: true, script: "bash ${WORKSPACE}/scripts/bump_version.sh -c ${WORKSPACE}/CHANGELOG.md -v ${theLatestTag} | tail -n 1").trim()
          }
          currentBuild.displayName = "Tag: $dockerTag"
          sh (returnStdout: true, script: "bash ${WORKSPACE}/scripts/find_changed_services.sh").trim().split(" ").each { changedService ->
            if (changedService != "") {
              listChangeServices.add(changedService)
            }
          }
        }
      }
    }

    stage('Configure'){
      steps {
        //Docker Login
        withCredentials([usernamePassword(credentialsId: 'DockerHub_Account', usernameVariable: 'dockerHubAccount', passwordVariable: 'dockerHubPassword')]) {
          sh "docker login --username $dockerHubAccount --password $dockerHubPassword"
        }
      }
      
    }

    stage('Build Image') {
      steps {
        script {
          //Define docker image name and tag
          if (params.BUILD_ALL == true  || env.BRANCH_NAME == "staging") {
            listChangeServices=[]
            sh (returnStdout: true, script: "find -maxdepth 2 -type d | grep -E 'Point_of_Sale\$' | awk -F/ '{print \$3}' | sed ':a;N;\$!ba;s/\\n/ /g'").trim().split(" ").each { service ->
              listChangeServices.add(service)
            }
          }
          if (listChangeServices.size() != 0) {
            listChangeServices.each { serviceName ->
              try {
                dockerImage = "$dockerRepo/$project-${serviceName.toLowerCase().replaceAll("_","-").replaceAll("services","service")}:$dockerTag"
                echo "Building image for $serviceName ..."
                sh """
                  docker build -t $dockerImage -f Point_of_Sale.API/$serviceName/Dockerfile .
                """
                listSuccessImage.add(dockerImage)
              } catch ( Exception e) {
                echo "Exception: $e"
                listFailImage.add(dockerImage)
                updateGitlabCommitStatus name: "Build", state: "failed"
              }
            }
          }
          updateGitlabCommitStatus name: "Build", state: "success"
        }
      }
    }

    stage('Publish') {
      when {
        branch pattern: "^staging\$|^main\$", comparator: "REGEXP"
      }
      steps {
        gitlabCommitStatus("Publish") {
          script {
            if (listSuccessImage.size() == 0) {
              echo "Do not have success image to publish"
            } else {
              listSuccessImage.each { image ->
                sh "docker push $image"
              }
            }
          }
        }
      }
    }

    stage('Result') {
      steps {
        script {
          echo "List Fail"
          listFailImage.each { image ->
            echo "$image"
          }
          echo "List success"
          listSuccessImage.each { image ->
            echo "$image"
          }
        }
      }
    }

    stage('Deploy') {
      when {
        branch pattern: "^staging\$|^main\$", comparator: "REGEXP"
      }
      steps {
        gitlabCommitStatus("Deploy") {
          script {
            if (listSuccessImage.size() == 0) {
              echo "None success image or having failed image"
            } else {
              IP = server."${env.BRANCH_NAME}"
              withCredentials([sshUserPrivateKey(credentialsId: 'devops-ssh-key', keyFileVariable: 'identity', passphraseVariable: 'passphrase', usernameVariable: 'userName')]) {
                sh """
                  sshpass -P "passphrase" -p '${passphrase}' \
                  scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -P 26266 ${userName}@${IP}:~/workspace/point-of-sale/docker-compose.yaml docker-compose-server.yaml
                  yq eval-all '. as \$item ireduce ({}; . * \$item )' docker-compose.yaml docker-compose-server.yaml > docker-compose-merge.yaml
                """
                listSuccessImage.each { image ->
                  sh """
                    sed -i 's/${image.split(":")[0].replaceAll("/","\\\\/")}:.*/${image.replaceAll("/","\\\\/")}/g' docker-compose-merge.yaml
                  """
                }
                if (env.BRANCH_NAME == "staging") {
                  sh """
                    sed -i 's/dev/staging/g' docker-compose-merge.yaml
                  """
                }
                sh """
                  sshpass -P "passphrase" -p '${passphrase}' \
                  scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -P 26266 docker-compose-merge.yaml ${userName}@${IP}:~/workspace/point-of-sale/docker-compose.yaml
                  
                  sshpass -P "passphrase" -p '${passphrase}' \
                  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -p 26266 ${userName}@${IP} 'docker-compose -f ~/workspace/point-of-sale/docker-compose.yaml up -d'
                """
              }
            }
          }
        }
      }
    }
  }

  post { 
    always {
      script {
        withCredentials([string(credentialsId: 'jenkins-telegram-bot', variable: 'botToken')]) {
          listSuccess = printAll(listSuccessImage)
          listFailed = printAll(listFailImage)
          if (env.BRANCH_NAME == "develop") {
            message = "URL: ${env.BUILD_URL}\nBuild ${dockerTag}\nBuildPass: $listSuccess\nBuildFailed: $listFailed\nBuild Status: ${currentBuild.currentResult}".replace("192.168.99.84","103.121.91.79").trim()
          } else {
            message = "URL: ${env.BUILD_URL}\nBuild ${dockerTag}\nBuildPass: $listSuccess\nBuildFailed: $listFailed\nEnv: ${env.BRANCH_NAME}\nBuild Status: ${currentBuild.currentResult}".replace("192.168.99.84","103.121.91.79").trim()
          }
          echo(message)
          sh "curl -X POST 'https://api.telegram.org/bot$botToken/sendMessage?chat_id=$chatID\\&text=${URLEncoder.encode(message)}'"
        }
        echo "Clean Up environment"
        listSuccessImage.each { image ->
          sh "docker rmi $image --force"
        }
        sh """
          # Remove unused container
          docker container prune --force
          # Remove unused image
          docker images | grep '<none>' || true
          docker image prune --force
        """
      }
    }
  }
}
